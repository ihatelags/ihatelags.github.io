<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solace area item/mob Decode</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a2e;
            color: #ffffff;
            line-height: 1.6;
        }
        .container {
            max-width: 900px;
            margin: auto;
        }
        pre, textarea {
            background-color: #162447;
            border-radius: 0.5rem;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-family: 'Fixedsys', 'Courier New', 'Courier', monospace;
            padding: 1rem;
            border: 1px solid #3d3d52;
            min-height: 20rem;
        }
        pre {
            line-height: 1.1;
        }
        #json-output {
            resize: vertical;
        }
    </style>
</head>
<body class="p-4 sm:p-8">
    <div class="container bg-gray-800 shadow-xl rounded-xl p-6 md:p-10">
        <h1 class="text-3xl sm:text-4xl font-extrabold text-purple-400 mb-2 text-center">MUD Item Decoder</h1>
        <p class="text-center text-gray-300 mb-8">
            Paste a MUD item, mob entry, or JSON data into the box below.
        </p>
        
        <div class="space-y-8">
            <!-- Input Panel -->
            <div>
                <h2 class="text-xl font-bold mb-4 text-purple-300">Item/Mob Data (Input)</h2>
                <textarea id="item-input" 
                          class="w-full bg-gray-900 text-gray-200 border-gray-700 rounded-lg p-4 resize-none focus:outline-none focus:ring-2 focus:ring-purple-500 transition-colors" 
                          placeholder="copy the item/mob data here"></textarea>
            </div>
            
            <!-- Output Panels -->
            <div>
                <h2 class="text-xl font-bold mb-4 text-purple-300">Decoded Output</h2>
                <pre id="item-output" class="w-full bg-gray-900 text-gray-200 border-gray-700 rounded-lg p-4 overflow-y-auto">
                    <p class="text-gray-400">Your decoded item or mob will appear here...</p>
                </pre>
            </div>
            
            <div>
                <h2 class="text-xl font-bold mb-4 text-purple-300">JSON Output</h2>
                <textarea id="json-output" 
                          class="w-full bg-gray-900 text-gray-200 border-gray-700 rounded-lg p-4 resize-none focus:outline-none focus:ring-2 focus:ring-purple-500 transition-colors"
                          placeholder="JSON representation will appear here..."></textarea>
            </div>
        </div>
        
        <!-- Help Section -->
        <div class="mt-8 pt-8 border-t border-gray-700">
            <h2 class="text-2xl font-bold mb-4 text-purple-300">Help & Flag Explanations</h2>
            <div class="space-y-6 text-gray-300">
                <div>
                    <h3 class="text-xl font-semibold text-purple-400 mb-2">Mob Flags</h3>
                    <p>This section provides detailed explanations of various flags that determine a mob's behavior and characteristics within the game.  </p>
                    <ul class="list-disc list-inside mt-4 space-y-2">
                        <li><b>is npc(A)</b>: The mob is an NPC.</li>
                        <li><b>sentinel(B)</b>: The mob is tied to its room and will not leave on its own.</li>
                        <li><b>scavenger(C)</b>: The mob will pick up items left on the ground.</li>
                        <li><b>wimpy(H)</b>: The mob will flee from combat when its health drops to 20%.</li>
                        <li><b>nopurge(V)</b>: This mob will not be automatically removed from the game.</li>
                        <li><b>update always(cc)</b>: The mob is always "active" and processed by the game engine.</li>
                        <li><b>aggressive(F)</b>: The mob will attack any character in its level range.</li>
                        <li><b>stay area(G)</b>: The mob will not leave the area defined by its virtual number range.</li>
                        <li><b>indoors(Y)</b>: The mob will not venture indoors.</li>
                        <li><b>outdoors(W)</b>: The mob will not venture outdoors.</li>
                        <li><b>banker(ee)</b>: This mob provides banking services.</li>
                        <li><b>pet(I)</b>: The mob is a pet that can be charmed.</li>
                        <li><b>train(J)</b>: The mob is a trainer for player attributes.</li>
                        <li><b>practice(K)</b>: The mob is a practitioner for skills.</li>
                        <li><b>cleric(Q)</b>: The mob can cast cleric spells.</li>
                        <li><b>mage(R)</b>: The mob can cast mage spells.</li>
                        <li><b>thief(S)</b>: The mob can use thief skills.</li>
                        <li><b>warrior(T)</b>: The mob can use warrior skills like bash or parry.</li>
                        <li><b>healer(aa)</b>: The mob can heal characters of its alignment for a fee.</li>
                        <li><b>undead(O)</b>: The mob is an undead creature.</li>
                        <li><b>noalign(U)</b>: The mob is not bound by a specific alignment.</li>
                    </ul>
                </div>
                <div>
                    <h3 class="text-xl font-semibold text-purple-400 mb-2">Body Parts</h3>
                    <p>These flags indicate the physical parts of a mob, which can be relevant for dismemberment or special attacks.</p>
                    <ul class="list-disc list-inside mt-4 space-y-2">
                        <li><b>head(A)</b>: Indicates the presence of this limb.</li>
                        <li><b>arms(B)</b>: Indicates the presence of these limbs.</li>
                        <li><b>legs(C)</b>: Indicates the presence of these limbs.</li>
                        <li><b>heart(D)</b>: Indicates the presence of this vital organ.</li>
                        <li><b>brains(E)</b>: Indicates the presence of this vital organ.</li>
                        <li><b>guts(F)</b>: Indicates the presence of these vital organs.</li>
                        <li><b>hands(G)</b>: Indicates the presence of these extremities, often for wearing specific gear.</li>
                        <li><b>feet(H)</b>: Indicates the presence of these extremities, often for wearing specific gear.</li>
                        <li><b>fingers(I)</b>: Indicates the presence of these extremities.</li>
                        <li><b>ear(J)</b>: Indicates the presence of this sensory organ.</li>
                        <li><b>eye(K)</b>: Indicates the presence of this sensory organ.</li>
                        <li><b>long tongue(L)</b>: A long tongue, similar to a lizard's.</li>
                        <li><b>eyestalks(M)</b>: Eyes on stalks.</li>
                        <li><b>tentacles(N)</b>: One or more tentacles.</li>
                        <li><b>fins(O)</b>: Indicates the presence of these body parts.</li>
                        <li><b>wings(P)</b>: Indicates the presence of these body parts.</li>
                        <li><b>tail(Q)</b>: Indicates the presence of this body part.</li>
                        <li><b>claws(U)</b>: Indicates the presence of these combat-capable parts.</li>
                        <li><b>fangs(V)</b>: Indicates the presence of these combat-capable parts.</li>
                        <li><b>horns(W)</b>: Indicates the presence of these combat-capable parts.</li>
                        <li><b>scales(X)</b>: Indicates the mob is covered in scales.</li>
                        <li><b>tusks(Y)</b>: Indicates the presence of these combat-capable parts.</li>
                    </ul>
                </div>
                <div>
                    <h3 class="text-xl font-semibold text-purple-400 mb-2">Form Flags</h3>
                    <p>These flags define the fundamental nature or form of a mob, affecting its abilities and interactions within the game world.</p>
                    <ul class="list-disc list-inside mt-4 space-y-2">
                        <li><b>amphibian(aa)</b>: An amphibian mob that can also swim.</li>
                        <li><b>animal(G)</b>: A mob with an animalistic intelligence (low reasoning).</li>
                        <li><b>biped(M)</b>: A mob that walks on two legs.</li>
                        <li><b>bird(W)</b>: A mob with a bird form.</li>
                        <li><b>blob(S)</b>: A formless mob, which can be a cloud or mist if combined with the 'mist' flag.</li>
                        <li><b>centaur(N)</b>: A mob with a humanoid torso and a beast's lower body.</li>
                        <li><b>cold blood(cc)</b>: A mob that is cold-blooded and cannot be seen with infrared vision.</li>
                        <li><b>construct(J)</b>: A magical mob, such as a golem.</li>
                        <li><b>crustacean(Q)</b>: A mob with a crustacean form, like a crab or lobster.</li>
                        <li><b>dragon(Z)</b>: A mob that is a dragon.</li>
                        <li><b>edible(A)</b>: The mob's corpse can be eaten.</li>
                        <li><b>fish(bb)</b>: A mob in the form of a fish, able to swim.</li>
                        <li><b>insect(O)</b>: An insect-form mob.</li>
                        <li><b>instant decay(D)</b>: The mob's corpse will disappear immediately upon death.</li>
                        <li><b>intangible(L)</b>: A mob that is immaterial, like a ghost.</li>
                        <li><b>magical(C)</b>: A mob with a magical nature, causing strange effects when eaten.</li>
                        <li><b>mammal(V)</b>: A mob that is a mammal.</li>
                        <li><b>mist(K)</b>: A partially material mob made of mist.</li>
                        <li><b>other(E)</b>: A mob that is not flesh and blood.</li>
                        <li><b>poison(B)</b>: The mob is poisonous when eaten.</li>
                        <li><b>reptile(X)</b>: A reptile mob that should also be cold-blooded.</li>
                        <li><b>sentient(H)</b>: A mob capable of higher reasoning.</li>
                        <li><b>snake(Y)</b>: A mob in the form of a snake, which should also be a reptile.</li>
                        <li><b>spider(P)</b>: An arachnid mob.</li>
                        <li><b>undead(I)</b>: A mob that is undead and not truly alive.</li>
                        <li><b>worm(R)</b>: An invertebrate, tube-shaped mob.</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Comprehensive mappings for the decoding logic.
        const ITEM_TYPES = {
            "light": 1, "scroll": 2, "wand": 3, "staff": 4, "weapon": 5, "phylactery": 6, "treasure": 8, "armor": 9,
            "potion": 10, "clothing": 11, "furniture": 12, "trash": 13, "container": 15, "drink_con": 17, "key": 18,
            "food": 19, "money": 20, "boat": 22, "corpse_npc": 23, "corpse_pc": 24, "fountain": 25, "pill": 26,
            "protect": 27, "map": 28, "portal": 29, "warp_stone": 30, "room_key": 31, "gem": 32, "jewelry": 33,
            "jukebox": 34, "clan_item": 35, "skeleton": 36, "spellbook": 37, "assassin_bomb": 38, "manual": 39,
            "spellbook_ii": 40, "instrument": 41, "questitem": 42, "resource": 43, "vial": 44, "pc_remains": 45,
            "launcher": 46, "ammo": 47, "ammo_container": 48
        };
        const WEAPON_CLASSES = {
            "exotic": 0-exotic, "sword": 1-sword, "dagger": 2-dagger, "spear": 3-spear, "mace": 4-mace, "axe": 5-axe, "flail": 6-flail, "whip": 7-whip,
            "polearm": 8-polearm, "staff": 9-staff, "shuriken": 10-shurikin
        };
        const EXTRA_FLAGS = {
            "A": "glow", "B": "hum", "C": "good", "D": "lock", "E": "evil", "F": "invis", "G": "magic", "H": "nodrop",
            "I": "no align change", "J": "anti good", "K": "anti evil", "L": "anti neutral", "M": "noremove",
            "N": "inventory", "O": "nopurge", "P": "rot death", "Q": "vis death", "R": "align changed",
            "S": "nonmetal", "T": "nolocate", "U": "melt drop", "V": "had timer", "W": "sell extract",
            "X": "purified", "Y": "burn proof", "Z": "nouncurse", "aa": "tattoo", "bb": "corpse no animate",
            "dd": "no look", "ff": "dragon corpse"
        };
        const WEAR_FLAGS = {
            "A": "take", "B": "wear finger", "C": "wear neck", "D": "wear body", "E": "wear head", "F": "wear legs",
            "G": "wear feet", "H": "wear hands", "I": "wear arms", "J": "wear shield", "K": "wear about",
            "L": "wear waist", "M": "wear wrist", "N": "wield", "O": "hold", "P": "no sac", "Q": "wear float",
            "R": "wear tattoo", "S": "wear sign"
        };
        const RESTRICT_FLAGS = {
            "A": "human", "B": "half elf", "C": "dwarf", "D": "elf", "E": "wild elf", "F": "dark elf", "G": "kender",
            "H": "gnome", "I": "minotaur", "J": "draconian", "K": "lich", "L": "cobar", "M": "fighter", "N": "knight",
            "O": "ranger", "P": "cleric", "Q": "druid", "R": "thief", "S": "assassin", "T": "mage w", "U": "mage r",
            "V": "mage b", "W": "outcast", "X": "solamnia", "Y": "takhisis", "Z": "guardian", "aa": "mage",
            "bb": "tower", "cc": "heretic", "dd": "warder", "ee": "entropy", "ff": "revenant"
        };
        const AFFECT_TYPES = {
            0: "none", 1: "strength", 2: "dexterity", 3: "intelligence", 4: "wisdom", 5: "constitution", 6: "gender", 7: "class",
            8: "level", 9: "age", 10: "height", 11: "weight", 12: "mana", 13: "hitpoints", 14: "move", 15: "move regeneration",
            16: "exp", 17: "armor class", 18: "hitroll", 19: "damroll", 20: "reflex save", 21: "will save", 22: "fortitude save",
            23: "resist earth", 24: "resist air", 25: "mana regeneration", 26: "morph form", 27: "hp regeneration",
            28: "resist bash", 29: "resist pierce", 30: "resist slash", 31: "resist fire", 32: "resist cold",
            33: "resist lightning", 34: "resist acid", 35: "resist poison", 36: "resist negative", 37: "resist holy",
            38: "resist energy", 39: "resist mental", 40: "resist disease", 41: "resist drowning", 42: "resist sound",
            43: "resist other", 44: "dam type", 45: "all saves", 46: "resist physical", 47: "spellpower",
            48: "sdm fire", 49: "sdm cold", 50: "sdm lightning", 51: "sdm acid", 52: "sdm poison", 53: "sdm negative",
            54: "sdm holy", 55: "sdm energy", 56: "sdm mental", 57: "sdm disease", 58: "sdm drowning", 59: "sdm other",
            60: "sdm sound", 61: "sdm air", 62: "sdm earth", 63: "dam undead", 64: "magic find", 65: "reflex spellforce",
            66: "will spellforce", 67: "fortitude spellforce", 68: "resist magic", 69: "dam elves", 70: "dam humans",
            71: "dam minotaurs", 72: "dam draconians", 73: "dam gnomes", 74: "dam dwarves", 75: "dam kenders",
            76: "dam dragons", 77: "precision", 78: "draw speed", 79: "shooting range"
        };
        const WEAPON_FLAGS = {
            "A": "flaming", "B": "frost", "C": "vampiric", "D": "sharp", "E": "vorpal", "F": "two-handed",
            "G": "shocking", "H": "poison", "I": "avenger", "J": "shadowbane", "K": "lightbringer"
        };
        
        // Comprehensive Mappings for Mobs
        const MOB_ACT_FLAGS = {
            "A": "is npc", "B": "sentinel", "C": "scavenger", "E": "astral watcher", "F": "aggressive",
            "G": "stay area", "H": "wimpy", "I": "pet", "J": "train", "K": "practice", "M": "archer",
            "O": "undead", "Q": "cleric", "R": "mage", "S": "thief", "T": "warrior", "U": "noalign",
            "V": "nopurge", "W": "outdoors", "Y": "indoors", "Z": "guild guard", "aa": "is healer",
            "bb": "gain", "cc": "update always", "dd": "wall", "ee": "banker", "ff": "extraplanar"
        };
        const MOB_AFFECT_FLAGS = {
            "A": "blind", "B": "invisible", "C": "detect evil", "D": "detect invis", "E": "detect magic",
            "F": "detect hidden", "G": "detect good", "H": "sanctuary", "I": "faerie fire", "J": "infrared",
            "K": "curse", "L": "instinct hunter", "M": "poison", "N": "protect evil", "O": "protect good",
            "P": "sneak", "Q": "hide", "R": "sleep", "S": "charm", "T": "flying", "U": "pass door",
            "V": "haste", "W": "calm", "X": "plague", "Y": "instinct preserve", "Z": "dark vision",
            "aa": "berserk", "bb": "swim", "cc": "regeneration", "dd": "slow", "ee": "camouflage",
            "ff": "acute vision"
        };
        const MOB_OFF_ASSIST_FLAGS = {
            "A": "area attack", "B": "backstab", "C": "bash", "D": "berserk", "E": "disarm", "F": "dodge",
            "G": "ground control", "H": "fast", "I": "kick", "J": "kick dirt", "K": "parry", "M": "tail",
            "N": "trip", "O": "crush", "P": "assist all", "Q": "assist align", "R": "assist race",
            "S": "assist players", "T": "assist guard", "U": "assist vnum", "V": "no track",
            "W": "static tracking", "X": "spam murder", "Z": "undead drain", "aa": "spellturning",
            "bb": "stances"
        };
        const MOB_IMM_FLAGS = {
            "A": "summon", "C": "magic", "D": "weapon", "E": "bash", "F": "pierce", "G": "slash", "H": "fire",
            "I": "cold", "J": "lightning", "K": "acid", "L": "poison", "M": "negative", "N": "holy",
            "O": "energy", "P": "mental", "Q": "disease", "R": "drowning", "T": "sound", "U": "air",
            "V": "earth", "aa": "ranged"
        };
        const MOB_RES_FLAGS = {
            "A": "summon", "C": "magic", "D": "weapon", "E": "bash", "F": "pierce", "G": "slash", "H": "fire",
            "I": "cold", "J": "lightning", "K": "acid", "L": "poison", "M": "negative", "N": "holy",
            "O": "energy", "P": "mental", "Q": "disease", "R": "drowning", "T": "sound", "U": "air",
            "V": "earth"
        };
        const MOB_VULN_FLAGS = {
            "A": "summon", "C": "magic", "D": "weapon", "E": "bash", "F": "pierce", "G": "slash", "H": "fire",
            "I": "cold", "J": "lightning", "K": "acid", "L": "poison", "M": "negative", "N": "holy",
            "O": "energy", "P": "mental", "Q": "disease", "R": "drowning", "T": "sound", "U": "air",
            "V": "earth"
        };
        const MOB_FORM_FLAGS = {
            "A": "edible", "B": "poison", "C": "magical", "D": "instant decay", "E": "other", "G": "animal",
            "H": "sentient", "I": "undead", "J": "construct", "K": "mist", "L": "intangible", "M": "biped",
            "N": "centaur", "O": "insect", "P": "spider", "Q": "crustacean", "R": "worm", "S": "blob",
            "V": "mammal", "W": "bird", "X": "reptile", "Y": "snake", "Z": "dragon", "aa": "amphibian",
            "bb": "fish", "cc": "cold blood"
        };
        const MOB_PART_FLAGS = {
            "A": "head", "B": "arms", "C": "legs", "D": "heart", "E": "brains", "F": "guts", "G": "hands",
            "H": "feet", "I": "fingers", "J": "ear", "K": "eye", "L": "long tongue", "M": "eyestalks",
            "N": "tentacles", "O": "fins", "P": "wings", "Q": "tail", "U": "claws", "V": "fangs",
            "W": "horns", "X": "scales", "Y": "tusks", "Z": "mountable", "cc": "cart"
        };
        const SEX_TYPES = {
            0: "neutral", 1: "male", 2: "female"
        };
        const POSITIONS = {
            0: "dead", 1: "mortally wounded", 2: "incapacitated", 3: "stunned", 4: "sleeping", 5: "resting",
            6: "standing", 7: "fighting"
        };
        const SIZE_TYPES = {
            0: "tiny", 1: "small", 2: "medium", 3: "large", 4: "huge", 5: "giant"
        };
        const DAMAGE_TYPES = {
            "digestion": "digestion", "acbite": "acidic bite", "slime": "slime", "bacid": "boiling acid", "acclaw": "acidic claw",
            "acblade": "acidic blade", "frbite": "freezing bite", "chill": "chill", "cgrasp": "chilling grasp",
            "frclaw": "freezing claw", "frblade": "freezing blade", "decay": "decay", "drowning": "drowning",
            "earth": "grasp of earth", "wrath": "wrath", "magic": "magic", "light": "blast of light",
            "nature": "force of nature", "fury": "deadly fury", "flbite": "flaming bite", "flame": "flame",
            "flclaw": "flaming claw", "flblade": "flaming blade", "divine": "divine power", "apocalypse": "apocalyptic power",
            "unholy": "unholy force", "rage": "zealous rage", "shbite": "shocking bite", "shock": "shock",
            "shclaw": "shocking claw", "shblade": "shocking blade", "lblast": "blast of lightning",
            "pain": "the pain of the damned", "vehemence": "vehemence", "drain": "life draining energy",
            "deathly": "deathly touch", "negative": "negative power", "soulless": "soulless cold",
            "defilement": "defilement", "ruin": "ruinous force", "darkness": "blast of darkness",
            "none": "hit", "pbite": "poisonous bite", "blast": "blast", "pound": "pound", "crush": "crush",
            "suction": "suction", "beating": "beating", "charge": "charge", "slap": "slap", "punch": "punch",
            "smash": "smash", "thwack": "thwack", "stab": "stab", "bite": "bite", "pierce": "pierce",
            "chomp": "chomp", "scratch": "scratch", "peck": "peck", "sting": "sting", "thrust": "thrust",
            "slice": "slice", "slash": "slash", "whip": "whip", "claw": "claw", "grip": "grip",
            "cleave": "cleave", "chop": "chop", "shear": "shearing blade", "shuriken": "shuriken",
            "spin": "spinning razor", "shredding": "shredding"
        };

        const itemInput = document.getElementById('item-input');
        const itemOutput = document.getElementById('item-output');
        const jsonOutput = document.getElementById('json-output');

        function getFlags(flagString, flagMap) {
            if (!flagString || flagString.length === 0) return [];
            const flags = new Set();
            for (const char of flagString) {
                if (flagMap[char]) {
                    flags.add(flagMap[char]);
                }
            }
            return Array.from(flags);
        }
        
        function parseDiceRoll(diceString) {
            const match = diceString.match(/^(\d+)d(\d+)([\+\-]\d+)?$/);
            if (!match) return { min: "Unknown", max: "Unknown", bonus: "Unknown", avg: "Unknown" };
            
            const numDice = parseInt(match[1]);
            const dieSides = parseInt(match[2]);
            const bonus = match[3] ? parseInt(match[3]) : 0;
            const min = numDice + bonus;
            const max = (numDice * dieSides) + bonus;
            const avg = (min + max) / 2;
            
            return { min, max, bonus, avg };
        }
        
        function readUntilTilde(lines, startIndex) {
            let content = "";
            let i = startIndex;
            while (i < lines.length) {
                const line = lines[i];
                if (line.endsWith('~')) {
                    content += line.substring(0, line.length - 1);
                    i++;
                    break;
                }
                if (line.trim() === '~') {
                    i++;
                    break;
                }
                content += line + '\n';
                i++;
            }
            return { content: content.trim(), nextIndex: i };
        }

        function decodeItem(data) {
            const lines = data.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            let lineIndex = 0;
            const nextLine = () => lines[lineIndex++];
            const hasNextLine = () => lineIndex < lines.length;
            
            const decoded = {
                vnum: "Unknown",
                name: "Unknown",
                shortDesc: "Unknown",
                longDesc: "Unknown",
                material: "Unknown",
                type: "Unknown",
                extraFlags: [],
                wearFlags: [],
                restrictFlags: [],
                stats: {},
                affects: [],
                specials: [],
                extraDesc: null
            };

            if (hasNextLine() && lines[lineIndex].startsWith('#')) {
                decoded.vnum = nextLine().substring(1);
            }
            decoded.name = hasNextLine() ? nextLine().replace(/~$/, '') : "Unknown";
            decoded.shortDesc = hasNextLine() ? nextLine().replace(/~$/, '') : "Unknown";
            
            let longDescResult = readUntilTilde(lines, lineIndex);
            decoded.longDesc = longDescResult.content;
            lineIndex = longDescResult.nextIndex;
            
            decoded.material = hasNextLine() ? nextLine().replace(/~$/, '') : "Unknown";
            
            let typeLineParts = hasNextLine() ? nextLine().split(' ') : [];
            let typeString = typeLineParts[0];
            
            decoded.type = typeString || "Unknown";
            
            // Correctly parse extra flags and wear flags from the same line
            // Only use the second and third parts if they exist
            if (typeLineParts.length > 1) {
              decoded.extraFlags = getFlags(typeLineParts[1], EXTRA_FLAGS);
            }
            if (typeLineParts.length > 2) {
              decoded.wearFlags = getFlags(typeLineParts[2], WEAR_FLAGS);
            }
            
            if (hasNextLine()) {
                const parts = nextLine().split(' ');
                if (decoded.type === "weapon") {
                    decoded.stats.weaponClass = WEAPON_CLASSES[parts[0]] || parts[0] || "Unknown";
                    decoded.stats.minDam = parseInt(parts[1]) || 0;
                    decoded.stats.maxDam = parseInt(parts[2]) || 0;
                    decoded.stats.damType = DAMAGE_TYPES[parts[3]] || parts[3] || "Unknown";
                    decoded.stats.weaponFlags = getFlags(parts[4], WEAPON_FLAGS);
                } else if (decoded.type === "armor" || decoded.type === "treasure" || decoded.type === "trash") {
                    decoded.stats.ac = {
                        pierce: parseInt(parts[0]) || 0,
                        bash: parseInt(parts[1]) || 0,
                        slash: parseInt(parts[2]) || 0,
                        exotic: parseInt(parts[3]) || 0
                    };
                }
            }
            
            if (hasNextLine()) {
                const parts = nextLine().split(' ');
                decoded.stats.level = parseInt(parts[0]) || 0;
                decoded.stats.weight = parseInt(parts[1]) || 0;
                decoded.stats.cost = parseInt(parts[2]) || 0;
                // Only add extra flags from this line if the value exists and is a valid flag
                if (parts.length > 3 && parts[3].length > 0) {
                    const newExtraFlags = getFlags(parts[3], EXTRA_FLAGS);
                    // Filter out 'rot death' as per user feedback for this line
                    const filteredFlags = newExtraFlags.filter(flag => flag !== 'rot death');
                    decoded.extraFlags.push(...filteredFlags);
                }
            }
            
            while (hasNextLine()) {
                const line = lines[lineIndex].trim();
                const firstChar = line[0];

                if (line === 'A') { // New format: 'A' on its own line
                    nextLine(); // Consume the 'A'
                    if (hasNextLine()) {
                        const parts = nextLine().split(' ');
                        const type = parseInt(parts[0]) || 0;
                        const value = parseInt(parts[1]) || 0;
                        decoded.affects.push({ type, value });
                    }
                } else if (firstChar === 'A' && line.trim().length > 1) { // Old format: 'A' followed by data
                    const parts = nextLine().split(' ');
                    const type = parseInt(parts[1]) || 0;
                    const value = parseInt(parts[2]) || 0;
                    decoded.affects.push({ type, value });
                } else if (firstChar === 'E') {
                    nextLine(); // Consume the 'E' flag
                    const extraDescKeywords = nextLine().replace(/~$/, '');
                    const extraDescResult = readUntilTilde(lines, lineIndex);
                    decoded.extraDesc = {
                        keywords: extraDescKeywords,
                        content: extraDescResult.content
                    };
                    lineIndex = extraDescResult.nextIndex;
                } else if (firstChar === 'L') {
                    decoded.stats.limit = nextLine().split(' ')[1];
                } else if (firstChar === 'R') {
                    const parts = nextLine().split(' ');
                    const newRestrictFlags = getFlags(parts[1], RESTRICT_FLAGS);
                    decoded.restrictFlags.push(...newRestrictFlags);
                } else if (firstChar === 'S') {
                    const sLineParts = nextLine().split(' ');
                    const actionType = sLineParts[1];
                    let spell = "Unknown";
                    let chance = "Unknown";
                    let multiplier = "Unknown";
                    
                    // Consume all descriptive lines until we find a line with numbers or a quoted string.
                    while (hasNextLine()) {
                        const nextLineText = lines[lineIndex].trim();
                        // Case 1: Quoted string and a number (e.g., "slow" 3)
                        const spellMatch = nextLineText.match(/"(.*)"\s+(\d+)/);
                        if (spellMatch) {
                            spell = spellMatch[1];
                            chance = parseInt(spellMatch[2], 10);
                            nextLine(); // Consume the line with the spell
                            break;
                        }
                        // Case 2: Two numbers (e.g., 2 10)
                        const numberMatch = nextLineText.match(/^(\d+)\s+(\d+)/);
                        if (numberMatch) {
                            multiplier = parseInt(numberMatch[1], 10);
                            chance = parseInt(numberMatch[2], 10);
                            nextLine(); // Consume the line with the numbers
                            break;
                        }
                        // If neither, it's just flavor text, consume it.
                        nextLine();
                    }

                    const specialObject = {
                        actionType: actionType
                    };
                    if (spell !== "Unknown") {
                        specialObject.spell = spell;
                    }
                    if (multiplier !== "Unknown") {
                        specialObject.multiplier = multiplier;
                    }
                    if (chance !== "Unknown") {
                        specialObject.chance = chance;
                    }

                    decoded.specials.push(specialObject);
                } else {
                    nextLine();
                }
            }
            return decoded;
        }
        
        function decodeMob(data) {
            const lines = data.split('\n').map(line => line.trim()).filter(line => line.length > 0);
            let lineIndex = 0;
            const nextLine = () => lines[lineIndex++];
            const hasNextLine = () => lineIndex < lines.length;

            const decoded = {
                vnum: "Unknown",
                keywords: "Unknown",
                shortDesc: "Unknown",
                longDesc: "Unknown",
                extraDesc: "Unknown",
                race: "Unknown",
                mobFlags: [],
                affectedByFlags: [],
                alignment: "Unknown",
                mobGroup: "Unknown",
                level: "Unknown",
                hitroll: "Unknown",
                hp: { min: "Unknown", max: "Unknown" },
                mana: { min: "Unknown", max: "Unknown" },
                damage: { min: "Unknown", max: "Unknown", bonus: "Unknown" },
                attackType: "Unknown",
                ac: "Unknown",
                offensiveAssists: [],
                immunities: [],
                resists: [],
                vulns: [],
                defaultPosition: "Unknown",
                fightingPosition: "Unknown",
                gender: "Unknown",
                silver: "Unknown",
                size: "Unknown",
                form: [],
                parts: []
            };

            const vnumLine = nextLine();
            decoded.vnum = vnumLine.startsWith('#') ? vnumLine.substring(1) : "Unknown";
            decoded.keywords = nextLine().replace(/~$/, '');
            decoded.shortDesc = nextLine().replace(/~$/, '');
            
            let longDescResult = readUntilTilde(lines, lineIndex);
            decoded.longDesc = longDescResult.content;
            lineIndex = longDescResult.nextIndex;
            
            let extraDescResult = readUntilTilde(lines, lineIndex);
            decoded.extraDesc = extraDescResult.content;
            lineIndex = extraDescResult.nextIndex;

            decoded.race = nextLine().replace(/~$/, '');
            
            const flagsLine = nextLine().split(' ');
            decoded.mobFlags = getFlags(flagsLine[0], MOB_ACT_FLAGS);
            decoded.affectedByFlags = getFlags(flagsLine[1], MOB_AFFECT_FLAGS);
            decoded.alignment = flagsLine[2] || "Unknown";
            decoded.mobGroup = flagsLine[3] || "Unknown";
            
            const statsLine = nextLine().split(' ');
            decoded.level = statsLine[0] || "Unknown";
            decoded.hitroll = statsLine[1] || "Unknown";
            decoded.hp = parseDiceRoll(statsLine[2]);
            decoded.mana = parseDiceRoll(statsLine[3]);
            decoded.damage = parseDiceRoll(statsLine[4]);
            decoded.attackType = DAMAGE_TYPES[statsLine[5]] || statsLine[5] || "Unknown";
            
            const acLine = nextLine().split(' ');
            decoded.ac = acLine.join(', ');
            
            const moreFlagsLine = nextLine().split(' ');
            decoded.offensiveAssists = getFlags(moreFlagsLine[0], MOB_OFF_ASSIST_FLAGS);
            decoded.immunities = getFlags(moreFlagsLine[1], MOB_IMM_FLAGS);
            decoded.resists = getFlags(moreFlagsLine[2], MOB_RES_FLAGS);
            decoded.vulns = getFlags(moreFlagsLine[3], MOB_VULN_FLAGS);
            
            const posSexGoldLine = nextLine().split(' ');
            decoded.defaultPosition = POSITIONS[posSexGoldLine[0]] || posSexGoldLine[0] || "Unknown";
            decoded.fightingPosition = POSITIONS[posSexGoldLine[1]] || posSexGoldLine[1] || "Unknown";
            decoded.gender = SEX_TYPES[posSexGoldLine[2]] || posSexGoldLine[2] || "Unknown";
            decoded.silver = posSexGoldLine[3] || "Unknown";
            
            const formPartsSizeLine = nextLine().split(' ');
            decoded.form = getFlags(formPartsSizeLine[0], MOB_FORM_FLAGS);
            decoded.parts = getFlags(formPartsSizeLine[1], MOB_PART_FLAGS);
            decoded.size = SIZE_TYPES[formPartsSizeLine[2]] || formPartsSizeLine[2] || "Unknown";
            
            return decoded;
        }

        // --- JSON Parsing and Formatting Functions ---
        function formatAlignment(alignment) {
            const num = parseInt(alignment, 10);
            if (num === -1000) return "evil";
            if (num === 0) return "neutral";
            if (num === 1000) return "good";
            return alignment;
        }

        function formatHtmlOutput(data) {
            const result = [];
            
            if (data.type) {
                result.push(`Vnum: ${data.vnum ?? 'Unknown'}`);
                result.push(`Name(s): ${data.name ?? 'Unknown'}`);
                result.push(`Type: ${data.type ?? 'Unknown'}`);
                result.push(`Wear Flags: ${data.wearFlags?.length > 0 ? data.wearFlags.join(', ') : 'none'}`);
                result.push(`Extra Flags: ${data.extraFlags?.length > 0 ? data.extraFlags.join(', ') : 'none'}`);
                result.push(`Restriction Flags: ${data.restrictFlags?.length > 0 ? data.restrictFlags.join(', ') : 'none'}`);

                if (data.type === "weapon") {
                    result.push(`Weapon Class: ${data.stats?.weaponClass ?? 'Unknown'}`);
                    result.push(`Damage: ${data.stats?.minDam ?? 0}d${data.stats?.maxDam ?? 0} (${((data.stats?.minDam ?? 0) + (data.stats?.minDam * (data.stats?.maxDam ?? 0)))/2} avg)`);
                    result.push(`Damage Type: ${data.stats?.damType ?? 'Unknown'}`);
                    if (data.stats?.weaponFlags?.length > 0) {
                        result.push(`Weapon Flags: ${data.stats.weaponFlags.join(', ')}`);
                    }
                } else if (data.type === "armor" || data.type === "treasure" || data.type === "trash") {
                    result.push(`Armor Class: Pierce(${data.stats?.ac?.pierce ?? 'Unknown'}), Bash(${data.stats?.ac?.bash ?? 'Unknown'}), Slash(${data.stats?.ac?.slash ?? 'Unknown'}), Exotic(${data.stats?.ac?.exotic ?? 'Unknown'})`);
                }

                result.push(`Level: ${data.stats?.level ?? 'Unknown'}`);
                result.push(`Weight: ${data.stats?.weight ?? 'Unknown'} (${((data.stats?.weight ?? 0) / 10).toFixed(1)} lbs)`);
                result.push(`Cost: ${data.stats?.cost ?? 'Unknown'}`);
                result.push(`Limit: ${data.stats?.limit ?? 'Unknown'}`);

                if (data.affects?.length > 0) {
                    result.push(`Affects:`);
                    data.affects.forEach(a => {
                        result.push(`  - ${AFFECT_TYPES[a.type] || `Type ${a.type}`} ${a.value > 0 ? '+' : ''}${a.value}`);
                    });
                }
                
                if (data.specials && data.specials.length > 0) {
                    result.push(`Specials:`);
                    data.specials.forEach(s => {
                        let specialText = `  - ${s.actionType}`;
                        if (s.spell) {
                            specialText += `: ${s.spell} (${s.chance}% chance)`;
                        } else if (s.multiplier) {
                            specialText += `: multiplier ${s.multiplier} (${s.chance}% chance)`;
                        }
                        result.push(specialText);
                    });
                }
            } else if (data.keywords) {
                result.push(`Vnum: ${data.vnum ?? 'Unknown'}`);
                result.push(`Keywords: ${data.keywords ?? 'Unknown'}`);
                result.push(`Short Description: ${data.shortDesc ?? 'Unknown'}`);
                result.push(`Race: ${data.race ?? 'Unknown'}`);
                result.push(`Mob Flags: ${data.mobFlags?.length > 0 ? data.mobFlags.join(', ') : 'none'}`);
                result.push(`Affected By: ${data.affectedByFlags?.length > 0 ? data.affectedByFlags.join(', ') : 'none'}`);
                result.push(`Alignment: ${formatAlignment(data.alignment)}`);
                result.push(`Mob Group: ${data.mobGroup ?? 'Unknown'}`);
                result.push(`Level: ${data.level ?? 'Unknown'}`);
                result.push(`Hitroll: ${data.hitroll ?? 'Unknown'}`);
                result.push(`Hit Points: ${data.hp?.min}-${data.hp?.max}`);
                result.push(`Mana: ${data.mana?.min}-${data.mana?.max}`);
                result.push(`Damage: ${data.damage?.min}-${data.damage?.max} (avg ${data.damage?.avg}), damroll: ${data.damage?.bonus}`);
                result.push(`Attack Type: ${data.attackType ?? 'Unknown'}`);
                result.push(`Armor Class: ${data.ac ?? 'Unknown'}`);
                result.push(`Offensive/Assists: ${data.offensiveAssists?.length > 0 ? data.offensiveAssists.join(', ') : 'none'}`);
                result.push(`Immunities: ${data.immunities?.length > 0 ? data.immunities.join(', ') : 'none'}`);
                result.push(`Resists: ${data.resists?.length > 0 ? data.resists.join(', ') : 'none'}`);
                result.push(`Vulns: ${data.vulns?.length > 0 ? data.vulns.join(', ') : 'none'}`);
                result.push(`Position: Starting(${data.defaultPosition ?? 'Unknown'}), Default(${data.fightingPosition ?? 'Unknown'})`);
                result.push(`Gender: ${data.gender ?? 'Unknown'}`);
                result.push(`Silver: ${data.silver ?? 'Unknown'}`);
                result.push(`Size: ${data.size ?? 'Unknown'}`);
                result.push(`Form: ${data.form?.length > 0 ? data.form.join(', ') : 'none'}`);
                result.push(`Parts: ${data.parts?.length > 0 ? data.parts.join(', ') : 'none'}`);
            }

            return result.join('\n');
        }

        function updateOutput() {
            const data = itemInput.value.trim();
            if (data.length === 0) {
                itemOutput.innerHTML = '<p class="text-gray-400">Your decoded item or mob will appear here...</p>';
                jsonOutput.value = '';
                return;
            }

            let decodedData = null;
            let isJson = false;
            try {
                decodedData = JSON.parse(data);
                isJson = true;
            } catch (e) {
                if (data.startsWith('#') || data.match(/^\S+~\n/)) {
                    const firstLines = data.split('\n').slice(0, 7).join(' ').toLowerCase();
                    if (firstLines.includes('weapon') || firstLines.includes('armor') || firstLines.includes('treasure') || firstLines.includes('trash')) {
                        decodedData = decodeItem(data);
                    } else {
                        decodedData = decodeMob(data);
                    }
                }
            }

            if (decodedData) {
                itemOutput.innerHTML = formatHtmlOutput(decodedData);
                jsonOutput.value = JSON.stringify(decodedData, null, 2);
            } else {
                itemOutput.innerHTML = '<p class="text-red-400">Error: Could not decode the input data. Please check the format.</p>';
                jsonOutput.value = '';
            }
        }
        
        itemInput.addEventListener('input', updateOutput);
        updateOutput();
    </script>
</body>
</html>
